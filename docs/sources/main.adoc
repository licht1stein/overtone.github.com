= Overtone User's Guide
:author: Hlöðver Sigurðsson
:revdate: April 26, 2018
:revnumber: 1.0
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: ../assets/img
:scriptsdir: js
:imagesoutdir: ../assets/img
:overtone-version: 0.10.3

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

++++
<link rel="stylesheet"  href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.1.0/css/font-awesome.min.css">
++++

:icons: font

ifdef::env-github[]
toc::[]
endif::[]

// TODO:

= Introduction

`Overtone` is an audio programming library useing the Supercollider syntheizer engine via the expressive programming language `Clojure`. It combines the power of Supercollider and Clojure enabeling many artistic endeavors, includeing:

* Sound design
* Musical composition
* Midi/OSC hardware interfaces
* Audio-visual compositions/installations
* Data science and "big data" art
* Live-coding
* DAW integration
* AbletonLive clock synchronization via AbletonLink
* RaspberryPI/Bela/Monome compatability

== Preface

It is my hope that this book will be a gentle introduction to `Overtone` to a complete beginner as well for a novice. If I were to tell you, dear reader, that a beginner could install Overtone and start makeing music without a hurdle, I would be lying. The computer can be amazing, exciting tool to fulfill our creative needs. But at the same time the computer, and its building blocks, computer programs and code, can be at times undescribeably painful, misconfigured and unpredictive. The hurdles you may encounter may include tooling, mac/linux/windows specific problems, files and libraries mislocated, version incompatabilities, and the list can go on forever. Luckily we will be getting ourselves comfortable with the programming language Clojure, which in the total 10 years of its existance, has seen an explosion of book publications, tutorials, workshops and stackoverflow questions/answers. So if you find youself in the unfortunate situation of getting stuck, your odds are good that someone else on the internet already had the same problem as you, and you're only one google search away from getting yourself back on track. At any point in time for any problem you are faceing, you should always feel welcome to open ticket on github, ask question on stackoverflow, the irc(freenode) or on slack(clojurians). The software community as a whole is riddled with micro-aggressive "bromance" behaviour and hence can be at times quite intimidateing for beginners to reach out for help. Which among other factors(in my subjective opinion), we end up with demographics of coders, be it art related or not, completly out of porpotion in relation to the demographics of the general population. Please be aware that the Clojure community has on all social-media platforms, meetups and conferences a set of guidelines for behaviour, protocols in case of violation and group of confidentials to report violations to.

As my personal advice to you for your journey into the world of creative codeing, don't believe everything software engineers tell you about software, in the same way you shouldn't believe everything an artist tells you about how art should be. An artist and software-enginner will and should approach code in totally different way. You will never hear stories about Beethoven implementing a Continous Integration test to determine if his 7th symphony accedentally lost a note while he was writing his 8th, or Stravinsky trip out on his Bassoon type checker when he wrote the introduction to the Rite of Spring. Learning from the best is always a good approach and becoming better at programming is only going to make you faster and more effective, but do watch out for the abyss of infinite information and take moderate actions. If our goal is to create art for the real world, be completly shameless if your code isn't orthodoxial as long as it produces the desired result and you had fun writing the code.


== About this Book


=== Work in Progress

This is a work in progress. If you find an error, please submit a PR to fix it, or an issue with details of the problem.

=== Contributing

This source for this book is hosted on https://github.com/overtone/overtone.github.com/docs/sources[Github].

=== Conventions Used

The examples and code used in this book will try to be as neutral as possible when it comes to choice of text-editor. All modern text editors have some sort of plugin to run and evaluate Clojure code. If you are starting out with the programming language Clojure, you may easily get confused or lost on how to replicate some of the examples in your text editor. Therefore we aim to make all of our examples repliceable useing nothing but Leiningen in the terminal via `lein repl`, and assume from the reader basic understanding of the terminal/cmd (if you know how to explore directories and install apps with the terminal, you probably know enough). Leiningen is the most popular build tool in Clojure and is the build tool that glues Overtone's sources and dependencies togeather. Overtone does work with alternative build tools like `boot`, as well as a standalone java jar file, but that and how to integrate Overtone to specific text-editor will not be included in this book.

= Installation

== Dependencies

You will need:

- Java SDK (Version 8). http://openjdk.java.net/install/[OpenJDK] or http://www.oracle.com/technetwork/java/javase/downloads/index.html[Oracle]
- https://leiningen.org/[Leiningen] or https://djpowell.github.io/leiningen-win-installer/[Leiningen windows-installer] or http://brewformulas.org/Leiningen[Leiningen via brew on OsX]


Optionally you could want:

- https://supercollider.github.io/download[Supercollider] for starting scsynth externally from Overtone
- https://git-scm.com/downloads[Git] for cloneing the Overtone repository from github

If running on Linux you must have JACK Audio connection toolkit version 2 or later (which `qjackctl` provides along with easy to use GUI)

.Ubuntu
```bash
$ sudo apt-get install qjackctl
```

.Fedora
```bash
$ sudo dnf install qjackctl
```

.CentOS
```bash
$ sudo yum install qjackctl
```

.NixOs (if useing internal-synth, libjack2 must be installed via nix-env with its nix-env lib dir on LD_LIBRARY_PATH or alternatively loaded into a nix-shell)
```bash
$ nix-env -i libjack2
```

== Setting up a project

Although it is possible to start Overtone directly from the https://github.com/overtone/overtone[github repository] by downloading it as zip or cloneing it with `git clone https://github.com/overtone/overtone.git` in the terminal. It is recommended that `Overtone` is used as any other Clojure library in your own project. So we will do exacly that.

First create an empty directory, we'll call it overtone (the name is irrelevant here) and go into it

```bash
$ mkdir overtone
$ cd overtone
```

Then in your text-editor, create a new textfile and save it into the newly created directory as `project.clj`, this is file that leiningen looks for inside the folder leiningen was started from (ie. you can't start leiningen in directory x and expect it to find `project.clj` in directory y). Then paste the following code into `project.clj` and save the file again.

[subs="verbatim,attributes"]
```clojure
(defproject overtone-tutorial "1.0.0"  
  :dependencies [[overtone/overtone "{overtone-version}"]]
  :native-path "native" 
  :source-paths ["src"])
```

With only one file in your directory run the following lein command and let's see what happens

```bash
$ lein deps
```
TIP: `lein deps` is actually a redundant command as `lein repl` implicitly fetches Clojure dependencies before starting the REPL. It is only useful if you want to fetch the dependencies without starting the REPL.


If you're running leiningen for the first time you should see whole bunch of text appearing to the screen, indicateing that leiningen is downloading the Clojure dependencies needed to run Overtone. After this process, directories `target` and `native` should have been created, both of these directories can be safely omitted if you're planing on save your code on for example github, and `target` can even be deleted at any time, by literally deleteing it or by running `lein clean` which by default deletes `target`, that will only be useful if you're trying to debug your program as `target` gets created every time you run leiningen to store various information irrelevant to us at this moment. But do keep `native` untouched as it stores the necessary files needed to run Supercollider from within Overtone.

Now let's start Clojure via `lein repl`

```bash
$ lein repl
```

TIP: REPL stands for READ-EVAL-PRINT-LOOP, and is a fancy word for the Clojure shell/interpreter. In simple terms, a [Clojure]REPL is any type of program or tool that you can give Clojure code to to be evaluated.

If all went right, you should see something similar in your terminal window
```bash
nREPL server started on port 34189 on host 127.0.0.1 - nrepl://127.0.0.1:34189
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.9.0
OpenJDK 64-Bit Server VM 1.8.0_172-02
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=>
```

Now for our sanity, let's see if this REPL prints `Hello World`

```Clojure
user=> (println "Hello World!")
Hello World!
nil
user=> 
```

Yup we are ready, then to the moment of truth, now let's boot up Overtone with this easy-to-remember command

```Clojure
(use 'overtone.live)
```

If all went accordingly without errors you should see something similar in your terminal window, note that I'm running here on Linux, so for me Jack will be automatically booted and connected.

```bash
user=> (use 'overtone.live)
--> Loading Overtone...
--> Booting internal SuperCollider server...
Found 0 LADSPA plugins
Cannot connect to server socket err = No such file or directory
Cannot connect to server request channel
Cannot lock down 82280346 byte memory area (Cannot allocate memory)
Cannot use real-time scheduling (RR/5)(1: Operation not permitted)
JackClient::AcquireSelfRealTime error
JackDriver: client name is 'SuperCollider'
SC_AudioDriver: sample rate = 48000.000000, driver's block size = 2048
--> Connecting to internal SuperCollider server...
--> Connection established
JackDriver: max output latency 128.0 ms

    _____                 __
   / __  /_  _____  _____/ /_____  ____  ___
  / / / / | / / _ \/ ___/ __/ __ \/ __ \/ _ \
 / /_/ /| |/ /  __/ /  / /_/ /_/ / / / /  __/
 \____/ |___/\___/_/   \__/\____/_/ /_/\___/

   Collaborative Programmable Music. v0.11


Hello Hlolli, may algorithmic beauty pour forth from your fingertips today.

nil
user=> 

```

TIP: If you're on Linux too and encounter `Cannot allocate memory` and/or `Cannot use real-time scheduleing` you can totally ignore that, it just means that you're not running preempt realtime-kernel. Switching to rt-kernel can potentially improve your audio performance by allowing Jack to send audio on top priority, but at the cost potentially make things very complicated and possibly insecure, as rt-kernels are usually released at much later than other kernels. If you want to run proprietary nvidia/ati drivers on preemt rt-kernel, you're most likely going too have a bad time, irrelevant if you're a linux expert or a beginner.


